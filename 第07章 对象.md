# 一、概述

## 1. 什么是对象？

对象（Object）是 JavaScript 的 核心概念，也是最重要的数据类型。JavaScript 的所有数据都可以被视为对象。简单说，所谓对象，就是一种 **无序** 的数据集合，由若干个 **键值对** （key-value，亦称属性名值对）构成。

JavaScript 支持面 **向对象编程** ，虽然不同于传统的面向对象编程语言，但是 JavaScript 具有很强的面向对象编程能力。“面向对象编程”（OOP，即 **O**bject **O**riented **P**rogramming）是目前主流的编程范式。它的核心思想是将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。

传统的 **过程式编程**（procedural programming）由一系列函数或一系列指令组成，而面向对象编程的程序由一系列对象组成。每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活性、代码的可重用性、模块性等特点，容易维护和开发，非常适合多人合作的大型软件项目。

那么，对象到底是什么？我们从两个层次来理解。

- **对象是单个实物的抽象。**

  一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。

- **对象是一个容器，封装了 “属性” 和 “方法”。**

  所谓“属性”，就是对象的状态；所谓“方法”，就是对象的行为（完成某种任务）。比如，我们可以把动物抽象为Animal对象，“属性”记录具体是那一种动物，“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。

## 2. 三大特征

- **封装**，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
- **继承**，指可以让某个类型的对象获得另一个类型的对象的属性和方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为 “**子类**” 或 “**派生类**”，被继承的类称为“**基类**”、“**父类**” 或 “**超类**”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过 “继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。
- **多态**，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。（比如输入的形参可以不同等去实现同一个方法从而得到不同的表现形式）

## 3. 六大基本原则

### OCP：开放封闭原则

开放封闭原则：(OCP，**O**pen－Close **P**rinciple)

**⭐️ 总纲，告诉我们要对扩展开发，对修改关闭**

实现：通过 “抽象约束、封装变化” 来实现开闭原则，即通过接口或者抽象类为软件实体 **定义一个相对稳定的抽象层**，而将相同的可变因素封装在相同的具体实现类中。

### SRP：单一职责原则

单一职责原则：(SRP，**S**ingle **R**esponsibility **P**rinciple)

**⭐️ 告诉我们实现类要职责单一**

实现：一个类只负责一项职责，一个方法只负责处理一项事情。

### LSP：里式替换原则

里式替换原则：(LSP，**L**iskov **S**ubstitution **P**rinciple)

定义1：**如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代替为o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。**

定义2：**所有引用基类的地方必须能透明地使用其子类的对象。**

**⭐️ 告诉我们不要破坏继承体系**

实现：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

### DIP：依赖倒置原则

依赖倒置原则：(DIP，**D**ependency **I**nversion **P**rinciple)

**⭐️ 告诉我们要面向接口编程**

实现：要面向接口编程，不要面向实现编程。

更加细致的要求：

- 每个类尽量提供接口或抽象类，或者两者都具备。
- 变量的声明类型尽量是接口或者是抽象类。
- 任何类都不应该从具体类派生。
- 使用继承时尽量遵循里氏替换原则。

### ISP：接口隔离原则

接口分离原则：(ISP， **I**nterface **S**egregation **P**rinciple)

**⭐️ 告诉我们在设计接口的时候要精简单一**

实现：客户端不应该被迫依赖于它不使用的方法。

和 单一职责原则 的区别：它和单一职责原则差不多，一个接口只服务于一个子模块或业务逻辑。只是单一职责是侧重于约束类和方法。而接口隔离侧重约束接口。

更加细致的要求：

- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同，深入了解业务逻辑。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

### CRP：合成复用原则

合成复用原则：（CRP：**C**omposite **R**euse **P**rinciple）

**⭐️ 告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。**

实现：合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

### LoD：迪米特法则

迪米特法则：（LoD，**L**aw **o**f **D**emeter）

**⭐️ 告诉我们要降低耦合度**

实现：只与你的直接朋友交谈，不跟 “陌生人” 说话。即如果两个对象无须直接通信，那么就不应当发生直接的相互调用，可以 **通过第三方转发该调用。**

从依赖者和被依赖者的角度的实现：

- 从依赖者的角度来说，只依赖应该依赖的对象；
- 从被依赖者的角度说，只暴露应该暴露的方法。

更加细致的要求：

- 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
- 在类的结构设计上，尽量降低类成员的访问权限。
- 在类的设计上，优先考虑将一个类设置成不变类。
- 在对其他类的引用上，将引用其他对象的次数降到最低。
- 不暴露类的属性成员，而应该提供相应的访问器（set和get方法）。
- 谨慎使用序列化（Serializable）功能。



# 二、创建对象

## 1. 原始模式 *

```javascript
// 1、原始模式，Object构造函数方式
var per = new Object();
per.name = "Muzili";
per.age = 32;
per.showName = function() {
  console.log(this.name);
}

// 2、原始模式，对象字面量方式 *
var per = {
  name: 'Muzili',
  age: 32,
  showName: function() {
    console.log(this.name);
  }
}
```

> 优势：创建单一对象时比较快捷方便。
>
> 缺陷：当我们要创建批量对象时，代码过于冗余。脱离对象原型。

> 提问：new 操作符具体做了什么事情？
>
> 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
>
> 2、属性和方法被加入到 this 引用的对象中。
>
> 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

## 2. 工厂模式

```javascript
function createPerson(name, age) {
	var obj = new Object();
	obj.name = name;
	obj.age  = age;
	obj.showName = function() {
		console.log(obj.name);
	}
	return obj;
}

var obj1 = createPerson('张三', 22);
var obj2 = createPerson('李四', 28);
```

> 优势：批量化生产，便捷方便。
>
> 缺陷：脱离对象原型。

## 3. 构造函数

```javascript
function Person(name, age) {
	this.name = name,
	this.age  = age,
	this.showName = function() {
		console.log(this.name);
	}
}
var per1 = new Person("张三", 22);
var per2 = new Person("李四", 28);
```

上面代码中，**Person** 就是构造函数，它提供模板，用来生成对象实例。为了与普通函数区别，构造函数名字的第一个字母通常大写。

构造函数的特点有两个。

- 函数体内部使用了 `this` 关键字，代表了所要生成的对象实例。
- 生成对象的时候，必需用 `new` 命令调用 `Person` 函数。

> 优势：对象实例拥有对象原型（ `constructor` ）
>
> ```javascript
> console.log(per1.constructor === Person); // true
> console.log(per2.constructor === Person); // true
> ```
> 缺陷：内存浪费

Javascript还提供了一个`instanceof` 运算符，验证原型对象与实例对象之间的关系。

```javascript
console.log(per1 instanceof Person); // true
console.log(per2 instanceof Person); // true
```

## 3. 原型模式

Javascript规定，每一个构造函数都有一个 `prototype` 属性，指向另一个对象。**这个对象的所有属性和方法，都会被构造函数的实例继承**。意味着，我们可以把那些不变的属性和方法，直接定义在`prototype`对象上。

```javascript
// 1、原型模式，直接定义prototype属性
function Person(){};
Person.prototype.name = "Muzili";
Person.prototype.age = 28;
Person.prototype.showName = function() {
  console.log(this.name);
}

// 2、原型模式，字面量定义方式
function Person () {}
Person.prototype = {
  name: 'Muzili',
  age: 28,
  showName: function () {
    console.log(this.name);
  },
};
var p1 = new Person(); // name='Muzili'
var p2 = new Person(); // name='Muzili'
```

## 5. 混合模式（构造 + 原型） *

```javascript
// 原型构造组合模式，
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype = {
  nationality: "China",
  showName: function() {
    console.log(this.name);
  }
}

var per1 = new Person("张三", 28);
var per2 = new Person("李四", 29);
```

> 提示：做法是将需要独立的属性方法放入构造函数中，而可以共享的部分则放入原型中，这样做可以最大限度节省内存而又保留对象实例的独立性。

# 三、属性与方法 *

## 1. 属性

在对象中，变量被认为是属性。属性向我们描述对象，比如王者荣耀一个英雄有名字、技能属性：

```javascript
// 1、键值对
var hero = {
  name: '李白',
  skill: '青莲剑歌',
};
// 2、点语法
var hero = {};
hero.name = '李白';
hero.skill = '青莲剑歌';

// 3、表达式
var hero = {};
hero['hero' + 'Name'] = '李白'; // === hero.heroName = "李白";
```

**访问对象属性**，主要有两种方法：

- 点语法，其语法形式为：`Obj.prop_name`，如  `hero.name`
- 下标法，其语法形式为：`Obj["prop_name"]`，如  `hero["name"]`

## 2. 方法

在对象中，函数被认为是方法。方法代表和对象相关的任务。例如一部车可以加速或减速行驶。

```javascript
var car = {
  // 属性
  brand: '东风本田',
  color: '珍珠白',
  model: '思域',
  // 方法
  speedUp: function () {
    console.log('正在加速！');
  },
  slowDown: function () {
    console.log('正在减速！');
  },
};
```

**访问对象方法**，直接通过点语法即可访问，其语法形式：`Obj.function_name()`，如  `car.speedUp()`

# 四、对象操作 *

对于数据操作来讲，无非就是四种操作“增、删、改、查”。对于对象来讲，“**增**” 就是为一个对象新增一个之前不存在的属性名，然后进行赋值；“**改**” 就是对对象已经存在的属性名进行重新赋值，达到一个修改原始对象的效果；而 “**查**” 就是简单地通过对象的属性名访问即可。这些我们之前都讲解过，但对于 “**删**”来讲稍微有些特殊，需要用到关键字 “`delete`” 进行操作，为了说明问题，我们还是对这些操作进行回顾并在其中列出delete的使用方式。原对象如下：

```javascript
var phone = {
  brand: '华为',
  model: 'P30 Pro',
  pubDate: '2019年4月10日',
};

{ brand: '华为', model: 'P30 Pro', pubDate: '2019年4月10日' }
```

## 1. 增

```javascript
phone.postAddress = "上海东方体育中心";

{
  brand: '华为',
  model: 'P30 Pro',
  pubDate: '2019年4月10日',
  postAddress: '上海东方体育中心'
}
```

## 2. 删

```javascript
delete phone.postAddress; 

{ brand: '华为', model: 'P30 Pro', pubDate: '2019年4月10日' }
```

## 3. 改

```javascript
phone.pubDate = "2019年4月11日";

{ brand: '华为', model: 'P30 Pro', pubDate: '2019年4月11日' }
```

## 4. 查

```javascript
phone.model;
P30 Pro
```

# 五、原型链 *

每个实例对象都有一个私有属性（称之为`__proto__` ）指向它的构造函数的原型对象（`prototype` ）。该原型对象也有一个自己的原型对象(`__proto__`) ，层层向上直到一个对象的原型对象为 `null`。

根据定义，`null` 没有原型，并作为这个**原型链** 中的最后一个环节。

```javascript
function Person(name, age) {
    this.name = name;
    this.age  = age;
}
var per = new Person("Admin", 28);
console.log(per.__proto__);  // Person.prototype
console.log(per.__proto__.__proto__);  // Object.prototype
console.log(per.__proto__.__proto__.__proto__); // null
```

![](IMGS/prototype-chain.png)

> 注意：
>
> 1. 只有函数才有 `prototype`。
> 2. `prototype` 原型对象包括了共享的属性、方法以及构造函数。
> 3. 上述示例中，`per` 实例对象，`Person.prototype` 原型对象，`Person` 构造函数。
> 4. `prototype.constructor`  指向构造函数。

# 六、对象继承 *

![](./IMGS/extends.png)

## 1. 原型链继承

核心：**将父类的实例作为子类的原型**。

```javascript
// -- 父类
function Person(name, age) {
  this.name = name || 'unknow';
  this.age = age || 0;
}
Person.prototype.say = function() {
  console.log("I'm person!");
}
// -- 子类
function Student(name) {
  this.name = name;
  this.major = '软件技术';
}

// -- 继承必须要写在子类方法定义的前面，否则子类定义的方法会被覆盖
Student.prototype = new Person();
Student.prototype.study = function() {
  console.log("I'm studing!");
}


var stu = new Student('张三');
console.log(stu.name);  // 子类覆盖父类的属性
console.log(stu.age);   // 父类属性
console.log(stu.major); // 子类自己的属性 
stu.say();              // 继承自父类的方法
stu.study();            // 子类自己的方法
```

以上代码就是原型链继承的实现了，但是原型链继承有一个缺点，就是属性如果是引用类型的话，会共享引用类型，请看以下代码：

```javascript
// -- 父类
function Person() {
  this.hobbies = ['music','reading']
}

// -- 子类
function Student(name) {}

// -- 继承
Student.prototype = new Person();

var stu1 = new Student();
var stu2 = new Student();

stu1.hobbies.push("game");
console.log(stu1.hobbies); // [ 'music', 'reading', 'game' ]
console.log(stu2.hobbies); // [ 'music', 'reading', 'game' ]
```

我们可以看到，当我们改变 `stu1` 的引用类型的属性时，`stu2` 对应的属性也会跟着更改，这就是原型链继承缺点：**引用属性会被所有实例共享**。

**总结**

1）优点：父类方法可以复用

2）缺陷：

- 父类的引用属性会被所有子类实例共享
- 子类构建实例时不能向父类传递参数

## 2. 构造函数继承

要解决原型链继承的缺陷，我们可以借用构造函数继承。

核心：**将父类构造函数的内容复制给了子类的构造函数**。这是所有继承中唯一一个不涉及到 `prototype` 的继承。

```javascript
// -- 父类
function Person() {
  this.hobbies = ['music','reading']
}

// -- 子类
function Student(name) {
  // 通过 call / apply实现继承
  Person.call(this, arguments);
  this.name = name;
}


var stu1 = new Student();
var stu2 = new Student();

stu1.hobbies.push("game");
console.log(stu1.hobbies); // [ 'music', 'reading', 'game' ]
console.log(stu2.hobbies); // [ 'music', 'reading' ]
```

构造函数解决了引用类型被所有实例共享的问题，但正是因为解决了这个问题，导致另一个很矛盾的问题出现了。

由于函数也是引用类型，所以函数也没办法共享了，也就是说，每个实例里面的函数，虽然功能一样，但是却不是同一个函数，就相当于我们每实例化一个子类，就复制了一遍函数代码。

```javascript
// -- 父类
function Person(name) {
  this.name = name;
  this.sayHi = function() {
    console.log("Hi");
  }
}

// -- 子类
function Student(name) {
  Person.call(this, name);
}

var stu1 = new Student("张三");
var stu2 = new Student("李四");

console.log(stu1);
console.log(stu2);
console.log(stu1.sayHi === stu2.sayHi);

Student { name: '张三', sayHi: [Function (anonymous)] }
Student { name: '李四', sayHi: [Function (anonymous)] }
false
```

以上代码可以证明，父类的函数，在子类的实例下是不共享的。

**总结：**

1）优点：

- 父类的引用属性不会被共享
- 子类构建实例时可以向父类传递参数

2）缺点：父类的方法不能复用，子类实例的方法每次都是单独创建的。

## 3. 组合继承

从上表的示例中我们可以看出 原型链继承 和 构造函数继承 这两种继承方式的优缺点刚好是互相矛盾的，那么我们有没有办法鱼和熊掌兼得呢？答案是肯定的，那就是使用组合继承把它们组合起来。

组合继承，就是各取上面两种继承的长处，普通属性 使用 构造函数继承，函数 使用 原型链继承，这个代码稍微复杂一点，不过相信有了上面的基础后，看起来也是很轻松。

```javascript
// -- 父类
function Person() {
  this.hobbies = ['music','reading']
}
Person.prototype.sayHi = function() {
  console.log('Hi');
}

// -- 子类
function Student(name) {
  Person.call(this, name);        // 构造函数继承(继承属性)
}
Student.prototype = new Person(); // 原型链继承(继承方法)

var stu1 = new Student();
var stu2 = new Student();

stu1.hobbies.push("game");
console.log(stu1.hobbies); // [ 'music', 'reading', 'game' ]
console.log(stu2.hobbies); // [ 'music', 'reading' ]
console.log(stu1.sayHi === stu2.sayHi); // true
```

这样，我们就既能实现属性的独立，又能做到函数的共享，是不是很完美呢?

**总结：**

1）优点

- 父类的方法可以被复用
- 父类的引用属性不会被共享
- 子类构建实例时可以向父类传递参数

2）缺点：调用了两次父类的构造函数，第一次给子类的原型添加了父类的 `hobbies` 属性，第二次又给子类的构造函数添加了父类的 `hobbies` 属性，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费。

## 4. 原型式继承

核心：原型式继承的 object 方法本质上是对参数对象的一个浅复制。
优点：父类方法可以复用
缺点：

- 父类的引用属性会被所有子类实例共享
- 子类构建实例时不能向父类传递参数

```javascript
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

var person = {
  name: '张三',
  hobbies: ['music', 'reading']
};

var p1 = object(person);
p1.name = '李四';
p1.hobbies.push('reading');

var p2 = object(person);
p2.name = '赵二';
p2.hobbies.push('swim');
console.log(person.hobbies); // [ 'music', 'reading', 'reading', 'swim' ]
```

> ECMAScript 5 通过新增 `Object.create()` 方法规范化了原型式继承。其语法形式如下：`Object.create(proto，[propertiesObject])`
>
> - `proto`：新创建对象的原型对象。
> - `propertiesObject`：为新对象定义额外属性的对象
>
> 在传入一个参数的情况下， `Object.create()`与 `object()` 方法的行为相同。——《JAVASCript高级编程》

所以上文中代码可以转变为：

```javascript
var p1 = object(person); // === var p1 = Object.create(person);
```

## 5. 寄生式继承

核心：使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力。
优缺点：仅提供一种思路，没什么优点

```javascript
function createAnother(original) {
  var clone = Object.create(original); // 通过调用函数创建一个新对象
  clone.sayHi = function () {   // 以某种方式来增强这个对象
    console.log('Hi');
  };
  return clone; // 返回这个对象
}

var person = {
  name: 'Nicholas',
  colors: ['red', 'green', 'blue'],
};

var anotherPerson = createAnother(person);
anotherPerson.sayHi(); // "Hi"
```

## 6. 寄生组合继承

刚才说到组合继承有一个会两次调用父类的构造函数造成浪费的缺点，寄生组合继承就可以解决这个问题。

所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。

- 实现思路： 不必为了指定子类型的原型而调用父类的构造函数，我们所需要的无非就是父类原型的一个副本而已
- 本质上，就是使用寄生式继承来继承父类的原型，然后再将结果指定给子类的原型。

```javascript
function $extends(subType, superType) {
  var prototype = Object.create(superType.prototype); // 创建对象
  prototype.constructor = subType; // 增强对象
  subType.prototype = prototype; // 指定对象
}
```

上述示例代码中，函数接收两个参数：子类构造函数和父类构造函数。在函数内部：

- 第一步是创建父类原型的一个副本。
- 第二步是为创建的副本添加 `constructor`  属性，从而弥补因重写原型而失去的默认的 `constructor` 属性。
- 最后一步，将新创建的对象（即副本）赋值给子类型的原型。

```javascript
function $extends(subType, superType) {
  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本
  prototype.constructor = subType; // 增强对象，弥补因重写原型而失去的默认的constructor 属性
  subType.prototype = prototype;  // 指定对象，将新创建的对象赋值给子类的原型
}

// -- 父类初始化实例属性和原型属性
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function () {
  console.log(this.name);
};

// -- 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}
// 将父类原型指向子类
$extends(SubType, SuperType);
// 新增子类原型属性
SubType.prototype.sayAge = function () {
  console.log(this.age);
};

var instance1 = new SubType("张三", 23);
var instance2 = new SubType("李四", 23);

instance1.colors.push("2"); // ["red", "blue", "green", "2"]
instance1.colors.push("3"); // ["red", "blue", "green", "3"]

```

上述代码的高效率体现在它只调用了一次 `SuperType` 构造函数，并且因此避免了在 `SubType. prototype` 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 `instanceof` 和 `isPrototypeOf()`，这是一种完美的继承方式。

## 7. ES6 Class extends

核心： ES6继承的结果和寄生组合继承相似，本质上，ES6继承是一种语法糖。但是，寄生组合继承是先创建子类实例 `this` 对象，然后再对其增强；而ES6先将父类实例对象的属性和方法，加到 `this` 上面（所以必须先调用 `super` 方法），然后再用子类的构造函数修改`this`。

```javascript
class A {}

class B extends A {
  constructor() {
    super();
  }
}
```

ES6实现继承的具体原理：

```javascript
class A {}

class B {}

Object.setPrototypeOf = function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
};

// B 的实例继承 A 的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B 继承 A 的静态属性
Object.setPrototypeOf(B, A);
```

ES6继承与ES5继承的异同：
1）相同点：本质上ES6继承是ES5继承的语法糖
2）不同点：

- ES6继承中子类的构造函数的原型链指向父类的构造函数，ES5中使用的是构造函数复制，没有原型链指向。
- ES6子类实例的构建，基于父类实例，ES5中不是。

# 七、对象的引用 *

如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。

```javascript
var car = {
	brand: "东风本田",
	model: "思域",
	color: "珍珠白"
};
var obj = car;
obj
// {brand: "东风本田", model: "思域", color: "珍珠白"}

obj.color = "炫动蓝";

obj
// {brand: "东风本田", model: "思域", color: "炫动蓝"}
car
// {brand: "东风本田", model: "思域", color: "炫动蓝"}
```

如果取消某一个变量对原对象的引用，不会影响到另一个变量。

```javascript
obj = null;
console.log(obj); // null
console.log(car); // { brand: '东风本田', model: '思域', color: '炫动蓝' }
```

# 八、数据类型嵌套使用 *

在实际开发过程中，通常会通过 `ajax` 向后台服务器发送请求，后台服务器一般返回 `json` 数据格式，json 数据格式的结构就是多种数据类型嵌套的一种形式，外层一般是对象或数组，接下来我们模拟一个登陆成功返回的数据形式，如下所示：

```js
var response = {
  status: 200,
  data: {
    username: 'lihy_online@163.com',
    age: 28,
    nikename: '木子李',
    tel: '152-2888-5771',
    isVip: true,
    tags: ['IT', '吉他', '烹饪', '老司机'],
  },
};
```

从上述代码中可以看出，res对象里面可以嵌套字符串、数值、数组、布尔值甚至还可以是一个对象，实际返回数据可能比这个更复杂。我们要做的事情是要学会读取这种复杂结构下的数据，比如我们要访问 ”老司机“，代码如下：

```javascript
res.data.tags[3]
```

在实际开发中，我们可以在代码中找到该对象，在该对象的后面输入 debugger，打开谷歌浏览器，鼠标右键，在控制台进行调试取值。

# 九、[Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)

## [Object.defineProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

数据劫持：该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

语法形式如下：

```javascript
Object.defineProperty(obj, prop, descriptor)
```

语法解读：

- `obj`：操作「对象」。
- `prop`：要定义或修改的「属性名称」。
- `descriptor`：将被定义或修改的「属性描述符」

对象属性一般来说可以修改也可以删除，使用 `Object.defineProperty()` 定义属性，通过描述符的设置可以进行更精准的对象属性控制。

**# 属性描述符**

通过 `Object.defineProperty()` 为对象定义属性，有两种形式，**且不能混合使用**，分别为数据描述符，存取描述符，下面分别描述下两者的区别：

**① 数据描述符**
| 属性           | 默认值      | 属性描述                                                     |
| -------------- | ----------- | ------------------------------------------------------------ |
| `value`        | `undefined` | 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。 |
| `writable`     | `false`     | 是否允许编辑                                                 |
| `configurable` | `false`     | 是否允许配置（改变属性的描述符 / 属性是否可以从对象上删除 `delete`） |
| `enumerable`   | `false`     | 是否出现在对象的枚举属性中                                   |

```js
var person = {};
Object.defineProperty(person, 'name', {
  value: '张三', // 属性值
  writable: false, // 是否可修改，默认为false
});

person.name = '李四';
console.log(person.name); // 张三
```

**② 存取描述符：set、get**

```js
let person = {
  desc: '',
};
Object.defineProperty(person, 'name', {
  get: function () {
    return '张三';
  },
  set: function (value) {
    this.desc = '我是' + value;
  },
});
console.log(person.name); // 张三
person.name = '李四';
console.log(person.name); // 张三
console.log(person.desc); // 我是李四
```

**# 数据描述符与存取描述均可使用的描述符**

1. `configrable`：描述属性是否配置，以及可否删除。
2. `enumerable` ：描述属性是否会出现在`for in` 或者 `Object.keys()` 的遍历中。

## [Object.preventExtensions(obj)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)

禁止对象扩展属性。

```js
let person = {
  name: "张三",
};
Object.preventExtensions(person);

person.name = "李四";
console.log(person); // {name: '张三'}

person.job = "程序员"; 
console.log(person); // {name: '张三'} -- 扩展属性失败
```

## Object.prototype.toString.call()

通过此方法可以精确匹配对象类型：

```js
function toRawType (target) {
  return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
}

console.log(toRawType([])); // array
console.log(toRawType({})); // object
console.log(toRawType("")); // string
console.log(toRawType(false)); // boolean
console.log(toRawType(0)); // number
console.log(toRawType(function(){})); // function
```

## [Object.seal(obj)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)

`Object.seal()` 会创建一个密封的对象，这个方法实际上会在一个现有对象上调用 `object.preventExtensions()` 并把所有现有属性标记为 `configurable:false`。

```js
let person = {
  name: '张三',
};

Object.seal(person);
person.age = 20;

console.log(person); // {name: '张三'}
delete person.name;
console.log(person); // {name: '张三'} -- 删除属性name失败
```

所以， 密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以改属性的值）。

## [Object.freeze(obj)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)

`Object.freeze()` 会创建一个 **冻结** 对象，这个方法实际上会在一个现有对象上调用 `Object.seal()` ，并把所有现有属性标记为 `writable: false`，这样就无法修改它们的值。

## [Obejct.entries(obj)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)

返回一个数组，其元素是与直接在`object`上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。

```js
var person = {
  name: '张三',
  job: '前端工程师',
  sex: '男',
};
for (var [key, value] of Object.entries(person)) {
  console.log(`${key}:${value}`);
}
name:张三
job:前端工程师
sex:男
```

## [Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。简单理解就是合并对象：

```javascript
var o1 = { name: '张三' };
var o2 = { major: '软件技术', name: '李四' };

var result = Object.assign(o1, o2);

console.log(result); // {name: '李四', major: '软件技术'}
console.log(result === o1); // true
```

## [Object.keys()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)

获取对象所有的 `key`

## [Object.values()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values)

获取对象所有的 `value`

## [Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

`Object.create()` 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（`prototype`）。

## [Object.getOwnPropertyNames()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)

返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。

# 十、拓展

## 1. 如何判断两个对象是否相等？

```javascript
Object.prototype.compare = function (object) {
  var propNamesA = Object.getOwnPropertyNames(this);
  var propNamesB = Object.getOwnPropertyNames(object);

  if (propNamesA.length !== propNamesB.length) {
    return false;
  }
    
  for (var i = 0; i < propNamesA.length; i++) {
    var propName = propNamesA[i];
    var valueA = this[propName];
    var valueB = object[propName];
    if (typeof valueA === 'object') {
      if (!valueA.compare(valueB)) {
        return false;
      }
    } else {
      if (valueA !== valueB) {
        return false;
      }
    }
  }
  return true;
};
```

试用：

```javascript
var o1 = { a: 1, b: { name: '张三' } };
var o2 = { b: { name: '张三' }, a: 1 };
console.log(o1.compare(o2));
// false
```

